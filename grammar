**Grammar**


#Starting symbol

start : (beginning_import_stm)?  stmt


#Imports

beginning_import_stmt : ( import_stmt | from_stmt )*

import_stmt: "IMPORT" module_name

from_stmt: "FROM" module_name "IMPORT" import_list

module_name: IDENTIFIER ('.' IDENTIFIER)*

import_list: import_name ("COLON" import_name)* 

import_name: IDENTIFIER [AS IDENTIFIER]?


#Statements within line

stmt: (_simple_stmt | _compound_stmt)* NEWLINE

_simple_stmt: assignment_stmt | declare_stmt | print_stmt | _multipleassignment_stmt | lambda_stmt | try_stmt | raise_stmt | logical_stmt

assignment_stmt: IDENTIFIER "EQUAL" exp

declare_stmt: "decl" (_multipleassignment_stmt | IDENTIFIER) ("COMMA" (_multipleassignment_stmt | IDENTIFIER))*

print_stmt: "PRINT" "LPAR" ("QUOTE" "STRING" "QUOTE" | exp ) "RPAR" 

_multipleassignment_stmt: assignment_stmt ("COMMA" assignment_stmt)?

lambda_stmt: "LAMBDA" [parameters] "COLON" exp

try_stmt: "TRY" "COLON" stmt (except_clause ["ELSE" "COLON" stmt] [FINALLY "COLON" stmt] | FINALLY "COLON" stmt)

except_clause: "CATCH" [exception_as] "COLON" stmt

exception_as: 'as' IDENTIFIER

raise_stmt: "RAISE" [exp ["FROM" exp ["RAISE" exp]]]


#Compound statements

_compound_stmt: if_stmt | while_stmt | for_stmt | function_def

if_stmt: "IF" "LPAR" exp "RPAR" "{" stmt "}" ("ELSIF" "LPAR" exp "RPAR"  "{" stmt "}")* ("ELSE" "{" stmt "}")?

while_stmt: "WHILE" ["BOOLEAN" | "LPAR" logical_stmt "RPAR" ] "COLON" loop_stmt

for_stmt: "FOR" "IDENTIFIER" "IN" "RANGE" "LPAR" "NUMBER" "RPAR"  "COLON" loop_stmt 

function_def:  "DEF" IDENTIFIER "LPAR" [parameters] "RPAR" ["ARROW" IDENTIFIER]? "COLON"  func_body


#Fillings for compund statements

loop_stmt: (stmt | flow_stmt )*

func_body : ( loop_stmt | return_stmt )*

flow_stmt: "BREAK" | "CONTINUE"

return_stmt: "RETURN" [explist]?

parameters: parameter ("COMMA" parameter)* 

parameter: IDENTIFIER ["COLON" exp]

explist: exp ("COMMA" exp)*

boolean: "TRUE" | "FALSE"


#Logical statements 

logical_stmt: and_stmt | inclusive_or_stmt | equality_expression

and_stmt : equalityexpression (AND" equalityexpression)+  # at least one AND

inclusive_or_stmt : equalityexpression ("OR" equalityexpression)+

equalityexpression : math_exp [("EQUAL""EQUAL"|"GREATER"|"SMALLER"|"EGREATER"| "ESMALLER") math_exp]*

math_exp: multiplicativeexpression (("PLUS"|"MINUS") multiplicativeexpression)*

multiplicativeexpression: castexpression (("MULTIPLY"|"DIVIDE"|MOD) castexpression)*

castexpression: (_unaryoperator?)_argument

_unaryoperator: (NOT|ECOMPLEMENT)

_argument: boolean |("LPAR" exp "RPAR")


exp : primary ((PLUS | MINUS | STAR | SLASH | AMPERSAND | LESS | GREATER | PERCENT | EQEQUAL | NOTEQUAL | LESSEQUAL | GREATEREQUAL | PLUSEQUAL | MINEQUAL | STAREQUAL | SLASHEQUAL | PERCENTEQUAL) primary)*;

primary : IDENTIFIER
        | NUMBER
        | STRING
        | LPAR expression CLOSE_PAREN
        | "{" explist "}"
        | "{" expression "}"
        | function_call

function_call : IDENTIFIER "LPAR" explist? "RPAR"




