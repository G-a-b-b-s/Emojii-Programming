


stmt: (_simple_stmt | _compound_stmt)* NEWLINE

_simple_stmt: _small_stmt

_small_stmt: assignment_stmt | flow_stmt | print_stmt | declare_stmt | return_stmt 

assignment_stmt: IDENTIFIER "ğŸŸ°" exp

declare_stmt: "decl" (_multipleassignment_stmt | IDENTIFIER) ("ğŸ“" (_multipleassignment_stmt | IDENTIFIER))*

flow_stmt: break_stmt | continue_stmt

break_stmt: "ğŸš¦"

continue_stmt: "ğŸ’†"

return_stmt: 'ğŸªƒ' [testlist]

print_stmt: "print" "ğŸ«·" ("\"âœï¸[A-za-z0-9-_\]âœï¸"\"" | exp) "ğŸ«¸" 

_compound_stmt: if_stmt | while_stmt | for_stmt | function_def |class_def

if_stmt: "â“" "ğŸ«·" exp "ğŸ«¸" "{" suite "}" ("â“â—" "ğŸ«·" exp "ğŸ«¸"  "{" suite "}")* ("â—â—" "{" suite "}")?


while_stmt: "ğŸŒªï¸" "ğŸ«·" for_test "ğŸ«¸" "{" suite "}"

##### TO ZLE - DO POPRAW DLA PYTHON
for_stmt: "ğŸ" "ğŸ«·" for_decl ";" for_test";" for_updates "ğŸ«¸" "{" suite "}"

for_decl: (declare_stmt | assignment_stmt)?

for_test: exp?

for_updates: _multipleassignment_stmt?

_multipleassignment_stmt: assignment_stmt ("ğŸ“" assignment_stmt)?

suite: (_simple_stmt | _compound_stmt)* NEWLINE

function_def: "ğŸ’¡" IDENTIFIER "ğŸ«·" [parameters] "ğŸ«¸" ['->' test] "ğŸ–‡ï¸" suite

parameters: parameter ("ğŸ“" parameter)* ["ğŸ“" [ '*' [parameter] ("ğŸ“" parameter)* ["ğŸ“" '**' parameter] | '**' parameter ] ]

parameter: IDENTIFIER ["ğŸ–‡ï¸" test]

class_def: 'class' IDENTIFIER ["ğŸ«·" [arglist] "ğŸ«¸"] [inheritance] "ğŸ–‡ï¸" suite

arglist: argument ("ğŸ“" argument)*  ["ğŸ“"]

inheritance: "ğŸ«·" testlist "ğŸ«¸"

argument: ( test [comp_for] |
            test "ğŸŸ°" test | # For keyword arguments
            '**' test | # For keyword arguments
            '*' test ) # For positional arguments

lambda_exp: "ğŸŒˆ" [parameters] "ğŸ–‡ï¸" test

ry_stmt: "ğŸ”®" "ğŸ–‡ï¸" suite (except_clause ["â—â—" "ğŸ–‡ï¸" suite] [FINALLY "ğŸ–‡ï¸" suite] | FINALLY "ğŸ–‡ï¸" suite)

except_clause: "ğŸ£" [exception_as] "ğŸ–‡ï¸" suite

exception_as: 'as' IDENTIFIER

raise_stmt: "ğŸŒ…" [test ["ğŸš›" test ["ğŸŒ…" test]]]

import_stmt: "ğŸŒ" module_name

from_stmt: "ğŸš›" module_name "ğŸŒ" import_list

module_name: IDENTIFIER ('.' IDENTIFIER)*

import_list: import_name ("ğŸ“" import_name)* ["ğŸ“"]

import_name: IDENTIFIER [AS IDENTIFIER]



?castexpression: (_unaryoperator?)_argument

?multiplicativeexpression: castexpression (("âœ–ï¸"|"â—"|EMOD) castexpression)*

?additiveexpression: multiplicativeexpression (("â•"|"â–") multiplicativeexpression)*

?equalityexpression: additiveexpression ((EEQU|ENOTEQ|ELESS|EGREA|EGREAE|ELESSE) additiveexpression)*

?andexpression: equalityexpression (("ğŸ‘­") equalityexpression)*



?inclusiveorexpression: exclusiveorexpression (("ğŸ•µï¸â€â™€ï¸") exclusiveorexpression)*



exp: logicalorexpression
_unaryoperator: (ENOT|ECOMPLEMENT)

##### CZY TU MAM DAC TE ZNAKI DLA NUMBER I IDENTIFIER CZY TAM TO ZAPISAC?
_argument: boolean | NUMBER | IDENTIFIER |("(" exp ")")

boolean: ğŸ‘ | ğŸ‘

ECOMPLEMENT: "ã€°"
ENOT: "â—"
EMOD: "%"| "mod"


