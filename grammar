


stmt: (_simple_stmt | _compound_stmt)* NEWLINE

_simple_stmt: _small_stmt

_small_stmt: assignment_stmt | flow_stmt | print_stmt | declare_stmt | return_stmt 

assignment_stmt: IDENTIFIER "EQUAL" exp

declare_stmt: "decl" (_multipleassignment_stmt | IDENTIFIER) ("COMMA" (_multipleassignment_stmt | IDENTIFIER))*

flow_stmt: "BREAK" | "CONTINUE"

return_stmt: "RETURN" [testlist]

print_stmt: "PRINT" "LPAR" ("QUOTE" "STRING" "QUOTE" | _argument | exp ) "RPAR" 

_compound_stmt: if_stmt | while_stmt | for_stmt | function_def |class_def

if_stmt: "IF" "LPAR" exp "RPAR" "{" suite "}" ("ELSIF" "LPAR" exp "RPAR"  "{" suite "}")* ("ELSE" "{" suite "}")?


while_stmt: "WHILE" "LPAR" for_test "RPAR" "{" suite "}"

for_stmt: "FOR" "IDENTIFIER" "IN" "RANGE" "LPAR" "NUMBER" "RPAR"  "{" suite "}"

for_decl: (declare_stmt | assignment_stmt)?

for_test: exp?

for_updates: _multipleassignment_stmt?

_multipleassignment_stmt: assignment_stmt ("COMMA" assignment_stmt)?

suite: (_simple_stmt | _compound_stmt)* NEWLINE

function_def:  "DEF" IDENTIFIER "LPAR" [parameters] "RPAR" ["ARROW" ] "COLON" suite

parameters: parameter ("COMMA" parameter)* 

parameter: IDENTIFIER ["COLON" exp]

class_def: 'class' IDENTIFIER ["LPAR" [arglist] "RPAR"] [inheritance] "COLON" suite

arglist: _argument ("COLON" _argument)*

inheritance: "LPAR" testlist "RPAR"
testlist: exp ("," exp)*

argument: ( exp [comp_for] |
            exp "EQUAL" exp | # For keyword arguments
            '**' exp | # For keyword arguments
            '*' exp ) # For positional arguments

lambda_exp: "LAMBDA" [parameters] "COLON" exp

try_stmt: "TRY" "COLON" suite (except_clause ["ELSE" "COLON" suite] [FINALLY "COLON" suite] | FINALLY "COLON" suite)

except_clause: "CATCH" [exception_as] "COLON" suite

exception_as: 'as' IDENTIFIER

raise_stmt: "RAISE" [exp ["FROM" exp ["RAISE" exp]]]

import_stmt: "IMPORT" module_name

from_stmt: "FROM" module_name "IMPORT" import_list

module_name: IDENTIFIER ('.' IDENTIFIER)*

import_list: import_name ("COLON" import_name)* 

import_name: IDENTIFIER [AS IDENTIFIER]



?castexpression: (_unaryoperator?)_argument

?multiplicativeexpression: castexpression (("MULTIPLY"|"DIVIDE"|MOD) castexpression)*

?additiveexpression: multiplicativeexpression (("PLUS"|"MINU") multiplicativeexpression)*

?equalityexpression: additiveexpression ((EEQU|ENOTEQ|ELESS|EGREA|EGREAE|ELESSE) additiveexpression)*

?andexpression: equalityexpression (("AND") equalityexpression)*

?inclusiveorexpression: exclusiveorexpression (("OR") exclusiveorexpression)*

exp: logicalorexpression
_unaryoperator: (NOT|ECOMPLEMENT)
_argument: boolean | NUMBER | IDENTIFIER |("(" exp ")")

boolean: "TRUE" | "FALSE"



