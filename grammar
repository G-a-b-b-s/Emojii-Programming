**Grammar**


#Starting symbol

start : (beginning_import_stm)?  stmt


#Imports

beginning_import_stmt : ( import_stmt | from_stmt )*

import_stmt: "IMPORT" module_name

from_stmt: "FROM" module_name "IMPORT" import_list

module_name: IDENTIFIER ('.' IDENTIFIER)*

import_list: import_name ("COLON" import_name)* 

import_name: IDENTIFIER [AS IDENTIFIER]?


#Statements within line

stmt: (_simple_stmt | _compound_stmt)* NEWLINE

_simple_stmt: assignment_stmt | declare_stmt | print_stmt | _multipleassignment_stmt | lambda_stmt | try_stmt | raise_stmt | exp

assignment_stmt: IDENTIFIER "EQUAL" exp

declare_stmt: "decl" (_multipleassignment_stmt | IDENTIFIER) ("COMMA" (_multipleassignment_stmt | IDENTIFIER))*

print_stmt: "PRINT" "LPAR" ("QUOTE" "STRING" "QUOTE" | exp ) "RPAR" 

_multipleassignment_stmt: assignment_stmt ("COMMA" assignment_stmt)?

lambda_stmt: "LAMBDA" [parameters] "COLON" exp

try_stmt: "TRY" "COLON" stmt (except_clause ["ELSE" "COLON" stmt] [FINALLY "COLON" stmt] | FINALLY "COLON" stmt)

except_clause: "CATCH" [exception_as] "COLON" stmt

exception_as: 'as' IDENTIFIER

raise_stmt: "RAISE" [exp ["FROM" exp ["RAISE" exp]]]


#Compound statements

_compound_stmt: if_stmt | while_stmt | for_stmt | function_def

if_stmt: "IF" "LPAR" exp "RPAR" "{" stmt "}" ("ELSIF" "LPAR" exp "RPAR"  "{" stmt "}")* ("ELSE" "{" stmt "}")?

while_stmt: "WHILE" ["BOOLEAN" | "LPAR" logical_stmt "RPAR" ] "COLON" loop_stmt

for_stmt: "FOR" "IDENTIFIER" "IN" "RANGE" "LPAR" "NUMBER" "RPAR"  "COLON" loop_stmt 

function_def:  "DEF" IDENTIFIER "LPAR" [parameters] "RPAR" ["ARROW" IDENTIFIER]? "COLON"  func_body


#Fillings for compund statements

loop_stmt: (stmt | flow_stmt )*

func_body : ( loop_stmt | return_stmt )*

flow_stmt: "BREAK" | "CONTINUE"

return_stmt: "RETURN" [explist]?

parameters: parameter ("COMMA" parameter)* 

parameter: IDENTIFIER ["COLON" exp]

explist: exp ("COMMA" exp)*

boolean: "TRUE" | "FALSE"


#Logical expression

logical_exp: and_exp | or_exp | equality_exp

#Math expression 

math_exp : add_exp | minus_exp | mult_exp | divide_exp |cast_exp

#Compare expression

comp_exp : greater_exp | greater_equal_exp | smaller_exp | smaller_equal_exp 

or_exp : exp( "OR" exp)+
and_exp : exp ("AND" exp)+
add_exp : exp ("PLUS" exp)+
minus_exp : exp ("MINUS" exp)+
mult_exp : exp ("MULTIPLY" exp)+
divide_exp : exp ("DIVIDE" exp)+
greater_exp :  exp ("GREATER" exp)+
greater_equal_exp :  exp ("EGREATER" exp)+
smaller_exp :  exp ("SMALLER" exp)+
smaller_equal_exp :  exp ("ESMALLER" exp)+
mod_exp : exp ("MOD" exp)+
equality_exp : exp ("EQUAL" "EQUAL" exp)+
cast_exp : unary_operator argument

# Expressions - important 

exp : logical_exp | math_exp | comp_exp | primary 

argument: boolean |("LPAR" exp "RPAR")

primary : IDENTIFIER
        | NUMBER
        | STRING
        | LPAR expression CLOSE_PAREN
        | function_call

function_call : IDENTIFIER "LPAR" explist? "RPAR"




