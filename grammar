


stmt: (_simple_stmt | _compound_stmt)* NEWLINE

_simple_stmt: _small_stmt

_small_stmt: assignment_stmt | flow_stmt | print_stmt | declare_stmt | return_stmt 

assignment_stmt: IDENTIFIER "EQUAL" exp

declare_stmt: "decl" (_multipleassignment_stmt | IDENTIFIER) ("COMMA" (_multipleassignment_stmt | IDENTIFIER))*

flow_stmt: "BREAK" | "CONTINUE"

return_stmt: "RETURN" [testlist]

print_stmt: "PRINT" "LPAR" ("QUOTE" "STRING" "QUOTE" | _argument | exp ) "RPAR" 

_compound_stmt: if_stmt | while_stmt | for_stmt | function_def |class_def

if_stmt: "IF" "LPAR" exp "RPAR" "{" stmt "}" ("ELSIF" "LPAR" exp "RPAR"  "{" stmt "}")* ("ELSE" "{" stmt "}")?


while_stmt: "WHILE" "LPAR" for_test "RPAR" "{" stmt "}"


for_stmt: "FOR" "IDENTIFIER" "IN" "RANGE" "LPAR" "NUMBER" "RPAR"  "{" stmt "}"


for_test: exp?



_multipleassignment_stmt: assignment_stmt ("COMMA" assignment_stmt)?


function_def:  "DEF" IDENTIFIER "LPAR" [parameters] "RPAR" ["ARROW" ] "COLON" NEWLINE stmt

parameters: parameter ("COMMA" parameter)* 

parameter: IDENTIFIER ["COLON" exp]

class_def: 'class' IDENTIFIER ["LPAR" [arglist] "RPAR"] [inheritance] "COLON" stmt

arglist: _argument ("COLON" _argument)*

inheritance: "LPAR" testlist "RPAR"

testlist: exp ("COMMA" exp)*



lambda_exp: "LAMBDA" [parameters] "COLON" exp

try_stmt: "TRY" "COLON" stmt (except_clause ["ELSE" "COLON" stmt] [FINALLY "COLON" stmt] | FINALLY "COLON" stmt)

except_clause: "CATCH" [exception_as] "COLON" stmt

exception_as: 'as' IDENTIFIER

raise_stmt: "RAISE" [exp ["FROM" exp ["RAISE" exp]]]

import_stmt: "IMPORT" module_name

from_stmt: "FROM" module_name "IMPORT" import_list

module_name: IDENTIFIER ('.' IDENTIFIER)*

import_list: import_name ("COLON" import_name)* 

import_name: IDENTIFIER [AS IDENTIFIER]



?castexpression: (_unaryoperator?)_argument

?multiplicativeexpression: castexpression (("MULTIPLY"|"DIVIDE"|MOD) castexpression)*

?additiveexpression: multiplicativeexpression (("PLUS"|"MINU") multiplicativeexpression)*

?equalityexpression: additiveexpression ((EEQU|ENOTEQ|ELESS|EGREA|EGREAE|ELESSE) additiveexpression)*

?andexpression: equalityexpression (("AND") equalityexpression)*

?inclusiveorexpression: exclusiveorexpression (("OR") exclusiveorexpression)*


exp : primary ((PLUS | MINUS | STAR | SLASH | AMPERSAND | LESS | GREATER | PERCENT | EQEQUAL | NOTEQUAL | LESSEQUAL | GREATEREQUAL | PLUSEQUAL | MINEQUAL | STAREQUAL | SLASHEQUAL | PERCENTEQUAL) primary)*;

primary : IDENTIFIER
        | NUMBER
        | STRING
        | LPAR expression CLOSE_PAREN
        | "{" testlist "}"
        | "{" expression "}"
        | function_call

function_call : IDENTIFIER "LPAR" testlist? "RPAR"

_unaryoperator: (NOT|ECOMPLEMENT)
_argument: boolean |("LPAR" exp "RPAR")

boolean: "TRUE" | "FALSE"

NEWLINE: '\n'

